LEX ANALYZER USING C


#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<ctype.h>

int kwd(char buffer[]);

int main(){
	char ch, buffer[15], buf[15], operators[] = "+-*/%=,;()";
	FILE *fp;
	int i,j=0;
	int ido=0;	

	char ids[26] = {'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'};
	


	fp = fopen("input.txt","r");
	
	if(fp == NULL){
		printf("error while opening the file\n");
		exit(0);
	}
	
	while((ch = fgetc(fp)) != EOF){

		for(i=0;i<10;i++)
			{
				if(ch == operators[i] && kwd(buffer) == 0)
					printf("id ");
			
			}
			
   		for(i = 0; i < 10; ++i){

			
   			if(ch == operators[i])
   		//		printf("operator");
				if(operators[i] == '+')
					printf("op-plus ");
				else if(operators[i] == '-')
					printf("op-sub ");
				else if(operators[i] == '*')
					printf("op-mul ");
				else if(operators[i] == '/')
					printf("op-div ");
				else if(operators[i] == '%')
					printf("op-mod ");
				else if(operators[i] == '=')
					printf("op-equ ");
				else if(operators[i] == ';')
					printf(";");
				else if(operators[i] == ',')
					printf(",");
				else if(operators[i] == '(')
					printf(".");
   		}

		
   		
   		if(isalnum(ch))
		{
			
   			buffer[j++] = ch;
			

   		}
   		else if((ch == ' ' || ch == '\n') && (j != 0))
		{
   				
				buffer[j] = '\0';
				
   				j = 0;
   				   				
   				if(kwd(buffer) == 1)
   					printf("kwd ");
				
				
   		}

		
		
	}
	
	fclose(fp);
	
	return 0;
}



int kwd(char buffer[]){
	char keywords[32][10] = {"auto","break","case","char","const","continue","default",
							"do","double","else","enum","extern","float","for","goto",
							"if","int","long","register","return","short","signed",
							"sizeof","static","struct","switch","typedef","union",
							"unsigned","void","volatile","while"};
	int i, flag = 0;
	
	for(i = 0; i < 32; ++i){
		if(strcmp(keywords[i], buffer) == 0){
			flag = 1;
			break;
		}
	}
	
	return flag;
	
}



/*int id( char buf[]){

	char ids[26] = {'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'};
	
	int i, flag = 0;
	
	for(i = 0; i < 62; ++i){
		if(strcmp(ids[i], buf) == 0){
			flag = 1;
			break;
		}
	}
	
	return flag;
}

*/

input.txt
int a,b,c;
a=b+c;




################################################################################################################################################################





LEXICAL ANALYZER USING LEX TOOL




 //Implementation of Lexical Analyzer using Lex tool
%{
int COMMENT=0;
%}
identifier [a-zA-Z][a-zA-Z0-9]*
%%
#.* {printf("\n%s is a preprocessor directive",yytext);}
int |
float |
char |
double |
while |
for |
struct |
typedef |
do |
if |
break |
continue |
void |
switch |
return |
else |
goto {printf(" kwd");}
"/*" {COMMENT=1;}{printf("comment");}
\+ {if(!COMMENT)printf(" op-plus");}
\- {if(!COMMENT)printf(" op-sub");}
\* {if(!COMMENT)printf(" op-mul");}
\/ {if(!COMMENT)printf(" op-div");}
{identifier}\( {if(!COMMENT)printf("fun");}
\{  {if(!COMMENT)printf("block begins");}
\}  {if(!COMMENT)printf("block ends");}
{identifier}(\[[0-9]*\])? {if(!COMMENT) printf(" id");}

\".*\" {if(!COMMENT)printf("str");}
[0-9]+ {if(!COMMENT) printf("num");}
\)(\:)? {if(!COMMENT)printf("\n\t");ECHO;printf("\n");}
\( ECHO;
= {if(!COMMENT)printf(" op-equ");}
\<= |
\>= |
\< |
== |
\> {if(!COMMENT) printf("rel-op");}

%%


int main(int argc, char **argv)
{
FILE *file;
file=fopen("input.c","r");
if(!file)
{
printf("could not open the file");
exit(0);
}
yyin=file;
yylex();
printf("\n");
return(0);
}
int yywrap()
{
return(1);
}


INPUT.C
int a,b,c;
a=b+c;

lex anaghasethu-p2.l
cc lex.yy.c
./a.out

OUTPUT:kwd id,id,id;
id op-equ id op-plus id;






#####################################################################################################################################################################






YACC PROGRAM TO FIND VALID IDENTIFIER


lex:
%{

    #include "y.tab.h"

%}

%%

[a-zA-Z_][a-zA-Z_0-9]* return letter;

[0-9]                       return digit;

.                      return yytext[0];

\n                     return 0;

%%

int yywrap()

{

return 1;

}


yacc:
%{

    #include<stdio.h>

    int valid=1;

%}

%token digit letter

%%

start : letter s

s :     letter s

      | digit s

      |

      ;

%%

int yyerror()

{

    printf("\nIts not a identifier!\n");

    valid=0;

    return 0;

}

int main()

{

    printf("\nEnter a name to tested for identifier ");

    yyparse();

    if(valid)

    {

        printf("\nIt is a identifier!\n");

    }

}





#################################################################################################################################################################





YACC TO FIND VALID ARITHMETIC EXPRESSION:



lex:
%{

    #include "y.tab.h"

%}

%%

[a-zA-Z_][a-zA-Z_0-9]* return id;

[0-9]+(\.[0-9]*)?      return num;

[+/*]                  return op;

.                      return yytext[0];

\n                     return 0;

%%

int yywrap()

{

return 1;

}


yacc:
%{

    #include<stdio.h>

    int valid=1;   

%}

%token num id op

%%

start :id '=' s ; | s ;

s :     id x       

      | num x      

      | '-' num x   

      | '(' s ')' x 

      ;

x :     op s        

      | '-' s       

      |             

      ;

%%

int yyerror()

{

    valid=0;

    printf("\nInvalid expression!\n");

    return 0;

}

int main()

{

    printf("\nEnter the expression:\n");

    yyparse();

    if(valid)

    {

        printf("\nValid expression!\n");

    }

}

OUTPUT:
yacc -d 11anaghasethu-p3.y
lex 11anaghasethu-p3.l
gcc lex.yy.c y.tab.c -w
./a.out


a=b+c
 Invalid expression
a=b+c;
 Valid expression
a=b+*
 Invalid expression







################################################################################################################################################################


CALCULATOR
LEX FILE:



%{ 
/* Definition section */
#include<stdio.h> 
#include "y.tab.h" 
extern int yylval; 
%} 

/* Rule Section */
%% 
[0-9]+ { 
		yylval=atoi(yytext); 
		return NUMBER; 

	} 
[\t] ; 

[\n] return 0; 

. return yytext[0]; 

%% 

int yywrap() 
{ 
return 1; 
} 




Yacc:

 %{

    #include<stdio.h>

    int flag=0;

   

%}

%token NUMBER



%left '+' '-'

%left '*' '/' '%'

%left '(' ')'

%%

ArithmeticExpression: E{

         printf("\nResult=%d\n",$$);

         return 0;

        };

E:E'+'E {$$=$1+$3;}

 |E'-'E {$$=$1-$3;}

 |E'*'E {$$=$1*$3;}

 |E'/'E {$$=$1/$3;}

 |E'%'E {$$=$1%$3;}

 |'('E')' {$$=$2;}

 | NUMBER {$$=$1;}

;

%%



void main()

{

   printf("\nEnter Any Arithmetic Expression:\n");

   yyparse();

  if(flag==0)

   printf("\n\n");

 

}

void yyerror()

{

   printf("\nInvalid\n\n");

   flag=1;

}

OUTPUT
yacc -d 11anaghasethu-p4.y
lex 11anaghasethu-p4.l
gcc lex.yy.c y.tab.c -w
./a.out

Enter Any Arithmetic Expression:
4+7
Result = 11
9*2
Result = 18
6/2
Result = 3
6-3
Result = 3
4++
Invalid




############################################################################################################################################################





EPSILON CLOSURE OF ALL STATES OF GIVEN NFA:



#include<stdio.h>
#include<stdlib.h>
struct node
{
        int st;
        struct node *link;
};

void findclosure(int,int);
void insert_trantbl(int ,char, int);
int findalpha(char);
void print_e_closure(int);

static int set[20],nostate,noalpha,s,notransition,c,r,buffer[20];
char alphabet[20];
static int e_closure[20][20]={0};
struct node * transition[20][20]={NULL};

void main()
{
        int i,j,k,m,t,n;
        struct node *temp;
        printf("Enter the number of alphabets?\n");
 scanf("%d",&noalpha);
        getchar();
        printf("NOTE:- [ use letter e as epsilon]\n");
        printf("NOTE:- [e must be last character ,if it is present]\n");
        printf("\nEnter alphabets?\n");
        for(i=0;i<noalpha;i++)
        {
                alphabet[i]=getchar();
                getchar();
        }
        printf("\nEnter the number of states?\n");
        scanf("%d",&nostate);
        printf("\nEnter no of transition?\n");
        scanf("%d",&notransition);
        printf("NOTE:- [Transition is in the form–> qno alphabet qno]\n",notransition);
        printf("NOTE:- [States number must be greater than zero]\n");
        printf("\nEnter transition?\n");
        for(i=0;i<notransition;i++)
        {
                scanf("%d %c%d",&r,&c,&s);
                insert_trantbl(r,c,s);
        }
 printf("\n");
        printf("e-closure of states……\n");
        printf("—————————–\n");
        for(i=1;i<=nostate;i++)
        {
                c=0;
                for(j=0;j<20;j++)
                {
                        buffer[j]=0;
                        e_closure[i][j]=0;
                }
                findclosure(i,i);
                printf("\ne-closure(q%d): ",i);
                print_e_closure(i);
        }
}

void findclosure(int x,int sta)
{
        struct node *temp;
        int i;
        if(buffer[x])
                return;
e_closure[sta][c++]=x;
        buffer[x]=1;
        if(alphabet[noalpha-1]=='e' && transition[x][noalpha-1]!=NULL)
        {
                temp=transition[x][noalpha-1];
                while(temp!=NULL)
                {
                        findclosure(temp->st,sta);
                        temp=temp->link;
                }
        }
}

void insert_trantbl(int r,char c,int s)
{
        int j;
        struct node *temp;
        j=findalpha(c);
        if(j==999)
        {
                printf("error\n");
                exit(0);
        }
 temp=(struct node *)malloc(sizeof(struct node));
        temp->st=s;
        temp->link=transition[r][j];
        transition[r][j]=temp;
}

int findalpha(char c)
{
        int i;
        for(i=0;i<noalpha;i++)
        if(alphabet[i]==c)
                return i;
        return(999);
}
void print_e_closure(int i)
{
        int j;
        printf("{");
        for(j=0;e_closure[i][j]!=0;j++)
        printf("q%d,",e_closure[i][j]);
        printf("}");
}

OUTPUT:
3

1
0
e

3

5

1 0 1
1 e 2
2 1 2
2 e 3
3 0 3


################################################################################################################################################################




CONVERSION OF EPSILON NFA TO NFA




#include<stdio.h>
#include<stdlib.h>
struct node
{
        int st;
        struct node *link;
};

void findclosure(int,int);
void insert_trantbl(int ,char, int);
int findalpha(char);
void findfinalstate(void);
void unionclosure(int);
void print_e_closure(int);
static int set[20],nostate,noalpha,s,notransition,nofinal,start,finalstate[20],c,r,buffer[20];
char alphabet[20];
static int e_closure[20][20]={0};
struct node * transition[20][20]={NULL};
void main()
{
           int i,j,k,m,t,n;

           struct node *temp;
           printf("enter the number of alphabets?\n");
           scanf("%d",&noalpha);
           getchar();
           printf("NOTE:- [ use letter e as epsilon]\n");

          printf("NOTE:- [e must be last character ,if it is present]\n");

          printf("\nEnter alphabets?\n");
          for(i=0;i<noalpha;i++)
         {

                  alphabet[i]=getchar();
                  getchar();
        }
        printf("Enter the number of states?\n");
        scanf("%d",&nostate);
        printf("Enter the start state?\n");
        scanf("%d",&start);
        printf("Enter the number of final states?\n");
        scanf("%d",&nofinal);
        printf("Enter the final states?\n");
        for(i=0;i<nofinal;i++)
                scanf("%d",&finalstate[i]);
         printf("Enter no of transition?\n");
        scanf("%d",&notransition);
        printf("NOTE:- [Transition is in the form--> qno   alphabet   qno]\n",notransition);
        printf("NOTE:- [States number must be greater than zero]\n");
        printf("\nEnter transition?\n");
        for(i=0;i<notransition;i++)
        {


                scanf("%d %c%d",&r,&c,&s);
                insert_trantbl(r,c,s);

        }

        printf("\n");

        for(i=1;i<=nostate;i++)
        {
                c=0;
                for(j=0;j<20;j++)

                {
                              buffer[j]=0;
                               e_closure[i][j]=0;
                }
                findclosure(i,i);
        }
        printf("Equivalent NFA without epsilon\n");
        printf("-----------------------------------\n");
        printf("start state:");
        print_e_closure(start);
        printf("\nAlphabets:");
        for(i=0;i<noalpha;i++)
                  printf("%c ",alphabet[i]);
        printf("\nStates :" );
        for(i=1;i<=nostate;i++)
                  print_e_closure(i);

        printf("\nTransitions are...:\n");

        for(i=1;i<=nostate;i++)
        {

                  for(j=0;j<noalpha-1;j++)
                 {
                          for(m=1;m<=nostate;m++)
                                        set[m]=0;
                          for(k=0;e_closure[i][k]!=0;k++)
                          {

                                    t=e_closure[i][k];
                                   temp=transition[t][j];
                                   while(temp!=NULL)
                                  {

                                             unionclosure(temp->st);
                                            temp=temp->link;
                                   }
                         }
                        printf("\n");
                        print_e_closure(i);
                        printf("%c\t",alphabet[j]   );
                        printf("{");
                        for(n=1;n<=nostate;n++)
                        {
                                     if(set[n]!=0)
                                             printf("q%d,",n);
                        }
                         printf("}");
                }
        }
        printf("\nFinal states:");
        findfinalstate();




}

void findclosure(int x,int sta)
{
            struct node *temp;
            int i;
           if(buffer[x])
                     return;
             e_closure[sta][c++]=x;
            buffer[x]=1;
             if(alphabet[noalpha-1]=='e' && transition[x][noalpha-1]!=NULL)
                {
                             temp=transition[x][noalpha-1];
                             while(temp!=NULL)
                            {
                                         findclosure(temp->st,sta);
                                         temp=temp->link;
                             }
                }
  }

void insert_trantbl(int r,char c,int s)
{
           int j;
           struct node *temp;
            j=findalpha(c);
          if(j==999)
          {
                     printf("error\n");
                    exit(0);
          }
         temp=(struct node *) malloc(sizeof(struct node));
         temp->st=s;
         temp->link=transition[r][j];
         transition[r][j]=temp;
}

int findalpha(char c)
{
            int i;
            for(i=0;i<noalpha;i++)
                   if(alphabet[i]==c)
                          return i;

                return(999);


}

void unionclosure(int i)
{
              int j=0,k;
             while(e_closure[i][j]!=0)
             {
                      k=e_closure[i][j];
                      set[k]=1;
                      j++;
             }
}
void findfinalstate()
{
            int i,j,k,t;
            for(i=0;i<nofinal;i++)
           {
                      for(j=1;j<=nostate;j++)
                      {
                              for(k=0;e_closure[j][k]!=0;k++)
                                {
                                         if(e_closure[j][k]==finalstate[i])
                                        {

                                                 print_e_closure(j);
                                        }
                               }
                      }
             }


  }

void print_e_closure(int i)
{
        int j=0;
        printf("{");
       if(e_closure[i][j]!=0)
                        printf("q%d,",e_closure[i][0]);
         printf("}\t");
}

OUTPUT:
enter the number of alphabets? 
3 
NOTE:- [ use letter e as epsilon] 
NOTE:- [e must be last character ,if it is present] 
Enter alphabets? 
a 
b 
e 
Enter the number of states? 
5 
Enter the start state? 
1 
Enter the number of final states? 
1 
Enter the final states? 
3 
Enter the number of transitions? 
7 
NOTE:- [Transition is in the form--> qno   alphabet   qno] 
NOTE:- [States number must be greater than zero] 
 
Enter transition? 
1 a 2 
1 e 3 
2 a 1 
3 b 4 
4 b 3 
3 a 5 
5 b 3 



########################################################################################################################################################################




NFA TO DFA CONVERSION:




#include<stdio.h>
#include<stdlib.h>
struct node
{
 int st;
 struct node *link;
};
struct node1
{

 int nst[20];
};

void insert(int ,char, int);
int findalpha(char);
void findfinalstate(void);
int insertdfastate(struct node1);
int compare(struct node1,struct node1);
void printnewstate(struct node1);
static int set[20],nostate,noalpha,s,notransition,nofinal,start,finalstate[20],c,r,buffer[20];
int complete=-1;
char alphabet[20];
static int eclosure[20][20]={0};
struct node1 hash[20];
struct node * transition[20][20]={NULL};
void main()
{
 int i,j,k,m,t,n,l;
 struct node *temp;
 struct node1 newstate={0},tmpstate={0};
 
 printf("Enter the number of alphabets?\n");
 printf("NOTE:- [ use letter e as epsilon]\n");
 printf("NOTE:- [e must be last character ,if it is present]\n");
 printf("\nEnter No of alphabets and alphabets?\n");
 scanf("%d",&noalpha);
 getchar();
 for(i=0;i<noalpha;i++)
 {

 alphabet[i]=getchar();
 getchar();
 }
 printf("Enter the number of states?\n");
 scanf("%d",&nostate);
 printf("Enter the start state?\n");
 scanf("%d",&start);
 printf("Enter the number of final states?\n");
 scanf("%d",&nofinal);
 printf("Enter the final states?\n");
 for(i=0;i<nofinal;i++)
 scanf("%d",&finalstate[i]);
 printf("Enter no of transition?\n");

 scanf("%d",&notransition);
 printf("NOTE:- [Transition is in the form–> qno alphabet qno]\n",notransition);
 printf("NOTE:- [States number must be greater than zero]\n");
 printf("\nEnter transition?\n");


 for(i=0;i<notransition;i++)
 {


  scanf("%d %c%d",&r,&c,&s);
  insert(r,c,s);

 }
 for(i=0;i<20;i++)
 {
  for(j=0;j<20;j++)
  hash[i].nst[j]=0;
 }
 complete=-1;
 i=-1;
 printf("\nEquivalent DFA.....\n");
 printf("Trnsitions of DFA\n");

 newstate.nst[start]=start;
 insertdfastate(newstate);
 while(i!=complete)
 {
  i++;
  newstate=hash[i];
  for(k=0;k<noalpha;k++)
  {
   c=0;
   for(j=1;j<=nostate;j++)
   set[j]=0;
   for(j=1;j<=nostate;j++)
   {
    l=newstate.nst[j];
    if(l!=0)
    {
     temp=transition[l][k];
     while(temp!=NULL)
     {
      if(set[temp->st]==0)
      {
       c++;
       set[temp->st]=temp->st;
      }
      temp=temp->link;


     }
    }
   }
   printf("\n");
   if(c!=0)
   {
    for(m=1;m<=nostate;m++)
     tmpstate.nst[m]=set[m];

    insertdfastate(tmpstate);

    printnewstate(newstate);
    printf("%c\t",alphabet[k]);
    printnewstate(tmpstate);
    printf("\n");
   }
   else
   {
    printnewstate(newstate);
    printf("%c\t", alphabet[k]);
    printf("NULL\n");
   }

  }
   }
 printf("\nStates of DFA:\n");
 for(i=0;i<=complete;i++)
 printnewstate(hash[i]);  
 printf("\n Alphabets:\n");
 for(i=0;i<noalpha;i++)
 printf("%c\t",alphabet[i]);
 printf("\n Start State:\n");
 printf("q%d",start);
 printf("\nFinal states:\n");
 findfinalstate();

}
int insertdfastate(struct node1 newstate)
{
 int i;
 for(i=0;i<=complete;i++)
 {
  if(compare(hash[i],newstate))
   return 0;
 }
 complete++;
 hash[complete]=newstate;
 return 1;
}
int compare(struct node1 a,struct node1 b)
{
 int i;


  for(i=1;i<=nostate;i++)
  {
   if(a.nst[i]!=b.nst[i])
    return 0;
  }
  return 1;


}

void insert(int r,char c,int s)
{
       int j;
       struct node *temp;
       j=findalpha(c);
       if(j==999)
       {
  printf("error\n");
  exit(0);
       }
       temp=(struct node *) malloc(sizeof(struct node));
       temp->st=s;
       temp->link=transition[r][j];
       transition[r][j]=temp;
}

int findalpha(char c)
{
 int i;
 for(i=0;i<noalpha;i++)
 if(alphabet[i]==c)
  return i;

  return(999);


}


void findfinalstate()
{
 int i,j,k,t;

 for(i=0;i<=complete;i++)
 {
  for(j=1;j<=nostate;j++)
  {
   for(k=0;k<nofinal;k++)
   {
    if(hash[i].nst[j]==finalstate[k])
    {
     printnewstate(hash[i]);
     printf("\t");
     j=nostate;
     break;
    }
   }
  }
 }
}


void printnewstate(struct node1 state)
{
 int j;
 printf("{");
  for(j=1;j<=nostate;j++)
  {
   if(state.nst[j]!=0)
    printf("q%d,",state.nst[j]);
  }
  printf("}\t");

}

OUTPUT:
Enter the number of alphabets? 
NOTE:- [ use letter e as epsilon] 
NOTE:- [e must be last character ,if it is present] 
Enter No of alphabets and alphabets? 
2 
a 
b 
Enter the number of states? 
4 
Enter the start state? 
1 
Enter the number of final states? 
2 
Enter the final states? 
3 
4 
Enter the number of transitions? 
8
NOTE:- [Transition is in the form–> qno alphabet qno] 
NOTE:- [States number must be greater than zero] 
 
Enter transition? 
1 a 1 
1 b 1 
1 a 2 
2 b 2 
2 a 3 
3 a 4 
3 b 4 
4 b 3 




###################################################################################################################################################################



FIRST AND FOLLOW



#include<stdio.h>
#include<math.h>
#include<string.h>
#include<ctype.h>
#include<stdlib.h>
int n,m=0,p,i=0,j=0;
char a[10][10],f[10];
void follow(char c);
void first(char c);
int main(){


int i,z;
char c,ch;
//clrscr();
printf("Enter the no of prooductions:\n");
scanf("%d",&n);
printf("Enter the productions:\n");
for(i=0;i<n;i++)
scanf("%s%c",a[i],&ch);
do{
m=0;
printf("Enter the elemets whose fisrt & follow is to be found:");
scanf("%c",&c);
first(c);
printf("First(%c)={",c);
for(i=0;i<m;i++)
printf("%c",f[i]);
printf("}\n");
strcpy(f," ");
//flushall();
m=0;
follow(c);
printf("Follow(%c)={",c);
for(i=0;i<m;i++)
printf("%c",f[i]);
printf("}\n");
printf("Continue(0/1)?");
scanf("%d%c",&z,&ch);
}while(z==1);
return(0);
}
void first(char c)
{
int k;
if(!isupper(c))
f[m++]=c;
for(k=0;k<n;k++)
{
if(a[k][0]==c)
{
if(a[k][2]=='$')
follow(a[k][0]);
else if(islower(a[k][2]))
f[m++]=a[k][2];
else first(a[k][2]);
}
}
}
void follow(char c)
{
if(a[0][0]==c)
f[m++]='$';
for(i=0;i<n;i++)
{
for(j=2;j<strlen(a[i]);j++)
{
if(a[i][j]==c)
{
if(a[i][j+1]!='\0')
first(a[i][j+1]);
if(a[i][j+1]=='\0' && c!=a[i][0])
follow(a[i][0]);
}
}
}
}
OUTPUT
5
S=AbCd
A=cf
A=a
C=gE
E=h




####################################################################################################################################################################




RECURSIVE DESCENT PARSER:





#include"stdio.h"
#include"string.h"
#include"stdlib.h"
#include"ctype.h"

char ip_sym[15],ip_ptr=0,op[50],tmp[50];
void e_prime();
void e();
void t_prime();
void t();
void f();
void advance();
int n=0;
void e()
{
 strcpy(op,"TE'");
 printf("E=%-25s",op);
 printf("E->TE'\n");
 t();
 e_prime();
}

void e_prime()
{
int i,n=0,l;
for(i=0;i<=strlen(op);i++)
    if(op[i]!='e')
 tmp[n++]=op[i];
strcpy(op,tmp);
l=strlen(op);
for(n=0;n < l && op[n]!='E';n++);
if(ip_sym[ip_ptr]=='+')
 {
     i=n+2;
 do
 {
 op[i+2]=op[i];
 i++;
 }while(i<=l);
  op[n++]='+';
  op[n++]='T';
  op[n++]='E';
  op[n++]=39;
  printf("E=%-25s",op);
  printf("E'->+TE'\n");
  advance();
  t();
  e_prime();
 }
 else
 {
     op[n]='e';
  for(i=n+1;i<=strlen(op);i++)
 op[i]=op[i+1];
 printf("E=%-25s",op);
 printf("E'->e");
 }
}
void t()
{
 int i,n=0,l;
 for(i=0;i<=strlen(op);i++)
  if(op[i]!='e')
   tmp[n++]=op[i];
 strcpy(op,tmp);
 l=strlen(op);
for(n=0;n < l && op[n]!='T';n++);

 i=n+1;
 do
 {
  op[i+2]=op[i];
  i++;
 }while(i < l);
 op[n++]='F';
 op[n++]='T';
 op[n++]=39;
 printf("E=%-25s",op);
 printf("T->FT'\n");
 f();
 t_prime();
}

void t_prime()
{
int i,n=0,l;
for(i=0;i<=strlen(op);i++)
    if(op[i]!='e')
 tmp[n++]=op[i];
strcpy(op,tmp);
l=strlen(op);
for(n=0;n < l && op[n]!='T';n++);
if(ip_sym[ip_ptr]=='*')
 {
     i=n+2;
 do
 {
 op[i+2]=op[i];
 i++;
 }while(i < l);
  op[n++]='*';
  op[n++]='F';
  op[n++]='T';
  op[n++]=39;
  printf("E=%-25s",op);
  printf("T'->*FT'\n");
  advance();
  f();
  t_prime();
 }
 else
 {
   op[n]='e';
  for(i=n+1;i<=strlen(op);i++)
 op[i]=op[i+1];
 printf("E=%-25s",op);
 printf("T'->e\n");
 }
}

void f()
{
int i,n=0,l;
for(i=0;i<=strlen(op);i++)
    if(op[i]!='e')
 tmp[n++]=op[i];
 strcpy(op,tmp);
l=strlen(op);
for(n=0;n < l && op[n]!='F';n++);
 if((ip_sym[ip_ptr]=='i')||(ip_sym[ip_ptr]=='I'))
 {
 op[n]='i';
 printf("E=%-25s",op);
 printf("F->i\n");
 advance();
 }
 else
 {
  if(ip_sym[ip_ptr]=='(')
  {
   advance();
   e();
   if(ip_sym[ip_ptr]==')')
   {
    advance();
     i=n+2;
 do
 {
 op[i+2]=op[i];
 i++;
 }while(i<=l);
  op[n++]='(';
  op[n++]='E';
  op[n++]=')';
  printf("E=%-25s",op);
  printf("F->(E)\n");
   }
  }
  else
  {
   printf("\n\t syntax error");
  
   exit(1);
  }
 }
}

void advance()
{
 ip_ptr++;
}

void main()
{
 int i;
 
 printf("\nGrammar without left recursion");
 printf("\n\t\t E->TE' \n\t\t E'->+TE'|e \n\t\t T->FT' ");
 printf("\n\t\t T'->*FT'|e \n\t\t F->(E)|i");
 printf("\n Enter the input expression:");
 scanf("%s",ip_sym);
 printf("Expressions");
 printf("\t Sequence of production rules\n");
  e();
  for(i=0;i < strlen(ip_sym);i++)
 {
  if(ip_sym[i]!='+'&&ip_sym[i]!='*'&&ip_sym[i]!='('&&
     ip_sym[i]!=')'&&ip_sym[i]!='i'&&ip_sym[i]!='I')
  {
   printf("\nSyntax error");
   break;
  }
  for(i=0;i<=strlen(op);i++)
    if(op[i]!='e')
 tmp[n++]=op[i];
    strcpy(op,tmp);
    printf("\nE=%-25s",op);
 }

}
output:
E->TE'
E'->+TE'|e
T->FT'
T'->*FT'|e
F->(E)|i

i+i


####################################################################################################################################################################


SHIFT REDUCE PARSER:


#include<stdio.h>
#include<string.h>
int k=0,z=0,i=0,j=0,c=0;
char a[16],ac[20],stk[15],act[10];
void check();
int main()
   {

      puts("GRAMMAR is E->E+E \n E->E*E \n E->(E) \n E->id");
      puts("enter input string ");
      scanf("%s",a);
      c=strlen(a);
      strcpy(act,"SHIFT->");
      puts("stack \t input \t action");
      for(k=0,i=0; j<c; k++,i++,j++)
       {
         if(a[j]=='i' && a[j+1]=='d')
           {
              stk[i]=a[j];
              stk[i+1]=a[j+1];
              stk[i+2]='\0';
              a[j]=' ';
              a[j+1]=' ';
              printf("\n$%s\t%s$\t%sid",stk,a,act);
              check();
           }
         else
           {
              stk[i]=a[j];
              stk[i+1]='\0';
              a[j]=' ';
              printf("\n$%s\t%s$\t%ssymbols",stk,a,act);
              check();
           }
       }

   }
void check()
   {
     strcpy(ac,"REDUCE TO E");
     for(z=0; z<c; z++)
       if(stk[z]=='i' && stk[z+1]=='d')
         {
           stk[z]='E';
           stk[z+1]='\0';
           printf("\n$%s\t%s$\t%s",stk,a,ac);
           j++;
         }
     for(z=0; z<c; z++)
       if(stk[z]=='E' && stk[z+1]=='+' && stk[z+2]=='E')
         {
           stk[z]='E';
           stk[z+1]='\0';
           stk[z+2]='\0';
           printf("\n$%s\t%s$\t%s",stk,a,ac);
           i=i-2;
         }
     for(z=0; z<c; z++)
       if(stk[z]=='E' && stk[z+1]=='*' && stk[z+2]=='E')
         {
           stk[z]='E';
           stk[z+1]='\0';
           stk[z+1]='\0';
           printf("\n$%s\t%s$\t%s",stk,a,ac);
           i=i-2;
         }
     for(z=0; z<c; z++)
       if(stk[z]=='(' && stk[z+1]=='E' && stk[z+2]==')')
         {
           stk[z]='E';
           stk[z+1]='\0';
           stk[z+1]='\0';
           printf("\n$%s\t%s$\t%s",stk,a,ac);
           i=i-2;
         }
   }
output:
id+id*id+id


################################################################################################################################################################


LOOP UNROLLING





#include<stdio.h>
void main()
{
unsigned int n;
int x;
char ch;

printf("\nEnter N\n");
scanf("%u",&n);
printf("\n1. Loop Roll\n2. Loop UnRoll\n");
printf("\nEnter ur choice\n");
scanf(" %c",&ch);
switch(ch)
{
case '1':
  x=countbit1(n);
  printf("\nLoop Roll: Count of  1's    :  %d" ,x);
  break;
case '2':
  x=countbit2(n);
  printf("\nLoop UnRoll:  Count of 1's  :  %d" ,x);
  break;
default:
  printf("\n Wrong Choice\n");

}
}
int countbit1(unsigned int n)
{
    int bits = 0,i=0;
    while (n != 0)
    {
 if (n & 1) bits++;
 n >>= 1;
 i++;
    }
    printf("Number of iterations  %d \n",i);
    return bits;
}
int countbit2(unsigned int n)
{
    int bits = 0,i=0;
    while (n != 0)
    {
 if (n & 1) bits++;
 if (n & 2) bits++;
 if (n & 4) bits++;
 if (n & 8) bits++;
 n >>= 4;
 i++;
    }
    printf("Number of iterations  %d \n",i);
    return bits;
}



############################################################################################################################################################################




CONSTANT PROPAGATION




#include<stdio.h>
#include<string.h>
#include<ctype.h>

void input();
void output();
void change(int p,char *res);
void constant();

struct expr{
	char op[2],op1[5],op2[5],res[5];
	int flag;
}arr[10];
int n;
void main(){
	
	input();
	constant();
	output();
}

void input(){
	
	int i;
	printf("\n\nEnter the maximum number of expressions : ");
	scanf("%d",&n);
	printf("\nEnter the input : \n");
	for(i=0;i<n;i++){
		scanf("%s",arr[i].op);
		scanf("%s",arr[i].op1);
		scanf("%s",arr[i].op2);
		scanf("%s",arr[i].res);
		arr[i].flag=0;
	}
}

void constant(){
	int i;
	int op1,op2,res;
	char op,res1[5];
	for(i=0;i<n;i++){
		if(isdigit(arr[i].op1[0]) && isdigit(arr[i].op2[0]) || strcmp(arr[i].op,"=")==0){
		/*if both digits, store them in variables*/
			op1=atoi(arr[i].op1);
			op2=atoi(arr[i].op2);
			op=arr[i].op[0];
			switch(op){
				case '+':
					res=op1+op2;
					break;
				case '-':
					res=op1-op2;
					break;
				case '*':
					res=op1*op2;
					break;
				case '/':
					res=op1/op2;
					break;
				case '=':
					res=op1;
					break;
			}
			sprintf(res1,"%d",res);
			arr[i].flag=1; 
			change(i,res1);
		}
	}
}

void output(){
	int i=0;
	printf("\nOptimized code is : ");
	for(i=0;i<n;i++){
		if(!arr[i].flag)
			printf("\n%s %s %s %s",arr[i].op,arr[i].op1,arr[i].op2,arr[i].res);
	}
}

void change(int p,char *res){
	int i;
	for(i=p+1;i<n;i++){
		if(strcmp(arr[p].res,arr[i].op1)==0)
			strcpy(arr[i].op1,res);
		else if(strcmp(arr[p].res,arr[i].op2)==0)
			strcpy(arr[i].op2,res);
	}
}

output:
4
= 3 - a
+ a b t1
+ a c t2
+ t1 t2 t3



######################################################################################################################################################################


LEX PROGRAM TO GET COUNT OF CH,D,P,N,SC,WS,O


%{ 
    int 
ch=0,digit=0,pos=0,neg=0,spl=0,spc=0,op=0; 
%} 
%% 
[0-9] digit++,pos++; 
[a-zA-Z] ch++; 
[-][0-9] neg++,digit++; 
[!@#$&()<>,.\{}:;"] spl++; 
[ \n\t] spc++; 
[+-/*^%=] op++; 
%% 
int main() 
{ 
    yyin = fopen("input.c","r"); 
yylex(); 
    printf("Character count:\t\t %d\n",ch); 
    printf("Digit count:\t\t\t %d\n",digit); 
    printf("Positive count:\t\t\t %d\n",pos); 
    printf("Negative count:\t\t\t %d\n",neg); 
    printf("Special character count:\t 
%d\n",spl); 
    printf("White space count:\t\t %d\n",spc); 
    printf("Operator count:\t\t\t %d\n",op); 
} 
int yywrap() 
{ 
    return 1; 
} 


######################################################################################################################################################################


LEX ANALYZER USING C



#include <stdbool.h> 
#include <stdio.h>
#include <string.h> 
#include <stdlib.h> 
// Returns 'true' if the character is a DELIMITER. 
bool isDelimiter(char ch) 
{ 
    if (ch == ' ' || ch == '+' || ch == '-' || ch == '*' ||  
        ch == '/' || ch == ',' || ch == ';' || ch == '>' ||  
        ch == '<' || ch == '=' || ch == '(' || ch == ')' ||  
        ch == '[' || ch == ']' || ch == '{' || ch == '}') 
        return (true); 
    return (false); 
} 
// Returns 'true' if the character is an OPERATOR. 
bool isOperator(char ch) 
{ 
    if (ch == '+' || ch == '-' || ch == '*' ||  
        ch == '/' || ch == '>' || ch == '<' ||  
        ch == '=') 
        return (true); 
    return (false); 
} 
// Returns 'true' if the string is a VALID IDENTIFIER. 
bool validIdentifier(char* str) 
{ 
    if (str[0] == '0' || str[0] == '1' || str[0] == '2' || 
        str[0] == '3' || str[0] == '4' || str[0] == '5' ||  
        str[0] == '6' || str[0] == '7' || str[0] == '8' ||  
        str[0] == '9' || isDelimiter(str[0]) == true) 
        return (false); 
    return (true); 
} 
// Returns 'true' if the string is a KEYWORD. 
bool isKeyword(char* str) 
{ 
    if (!strcmp(str, "if") || !strcmp(str, "else") || 
        !strcmp(str, "while") || !strcmp(str, "do") ||  
        !strcmp(str, "break") ||  
         !strcmp(str, "continue") || !strcmp(str, "int") 
        || !strcmp(str, "double") || !strcmp(str, "float") 
        || !strcmp(str, "return") || !strcmp(str, "char") 
        || !strcmp(str, "case") || !strcmp(str, "char") 
        || !strcmp(str, "sizeof") || !strcmp(str, "long") 
        || !strcmp(str, "short") || !strcmp(str, "typedef") 
        || !strcmp(str, "switch") || !strcmp(str, "unsigned") 
        || !strcmp(str, "void") || !strcmp(str, "static") 
        || !strcmp(str, "struct") || !strcmp(str, "goto")) 
        return (true); 
    return (false); 
} 
// Returns 'true' if the string is an INTEGER. 
bool isInteger(char* str) 
{ 
    int i, len = strlen(str); 
    if (len == 0) 
        return (false); 
    for (i = 0; i < len; i++) { 
        if (str[i] != '0' && str[i] != '1' && str[i] != '2' 
            && str[i] != '3' && str[i] != '4' && str[i] != '5' 
            && str[i] != '6' && str[i] != '7' && str[i] != '8' 
            && str[i] != '9' || (str[i] == '-' && i > 0)) 
            return (false); 
    } 
    return (true); 
} 
// Returns 'true' if the string is a REAL NUMBER. 
bool isRealNumber(char* str) 
{ 
    int i, len = strlen(str); 
    bool hasDecimal = false; 
    if (len == 0) 
        return (false); 
    for (i = 0; i < len; i++) { 
        if (str[i] != '0' && str[i] != '1' && str[i] != '2' 
            && str[i] != '3' && str[i] != '4' && str[i] != '5' 
            && str[i] != '6' && str[i] != '7' && str[i] != '8' 
            && str[i] != '9' && str[i] != '.' ||  
            (str[i] == '-' && i > 0)) 
            return (false); 
        if (str[i] == '.') 
            hasDecimal = true; 
    } 
    return (hasDecimal); 
} 
// Extracts the SUBSTRING. 
char* subString(char* str, int left, int right) 
{ 
    int i; 
    char* subStr = (char*)malloc( 
                  sizeof(char) * (right - left + 2));   
    for (i = left; i <= right; i++) 
        subStr[i - left] = str[i]; 
    subStr[right - left + 1] = '\0'; 
    return (subStr); 
} 
// Parsing the input STRING. 
void parse(char* str) 
{ 
    int left = 0, right = 0; 
    int len = strlen(str); 
    while (right <= len && left <= right) { 
        if (isDelimiter(str[right]) == false) 
            right++; 
        if (isDelimiter(str[right]) == true && left == right) { 
            if (isOperator(str[right]) == true) 
                printf("'%c' IS AN OPERATOR\n", str[right]); 
            right++; 
            left = right; 
        } else if (isDelimiter(str[right]) == true && left != right 
                   || (right == len && left != right)) { 
            char* subStr = subString(str, left, right - 1); 
            if (isKeyword(subStr) == true) 
                printf("'%s' IS A KEYWORD\n", subStr); 
            else if (isInteger(subStr) == true) 
                printf("'%s' IS AN INTEGER\n", subStr); 
            else if (isRealNumber(subStr) == true) 
               printf("'%s' IS A REAL NUMBER\n", subStr); 
           else if (validIdentifier(subStr) == true 
                  && isDelimiter(str[right - 1]) == false) 
                printf("'%s' IS A VALID IDENTIFIER\n", subStr); 
            else if (validIdentifier(subStr) == false 
                     && isDelimiter(str[right - 1]) == false) 
                printf("'%s' IS NOT A VALID IDENTIFIER\n", subStr); 
            left = right; 
        } 
    } 
    return; 
} 
int main() 
{ 
     // maximum legth of string is 100 here  
    char str[100] = "int c = 8a * b ; "; 
    parse(str); // calling the parse function 
    return (0); 
} 



#############################################################################################################################################################



VALID ARITHATIC EXPRESSION

lex:
%{ 
    #include<stdio.h> 
    #include "y.tab.h" 
    extern int yylval; 
%} 
%% 
[0-9]+ { 
    yylval=atoi(yytext); 
    return NUMBER; 
 } 
[\t] ; 
[\n] return 0; 
. return yytext[0]; 
%% 
int yywrap() 
{ 
    return 1; 
} 


yacc:
%{ 
    #include<stdio.h> 
    int flag=0; 
%} 
%token NUMBER 
%left '+' '-' 
%left '*' '/' '%' 
%left '(' ')' 
%% 
E:E'+'E 
|E'-'E 
|E'*'E   
|E'/'E 
|E'%'E 
|'('E')' 
| NUMBER 
; 
%% 
void main() 
{ 
    printf("Enter Expression: "); 
    yyparse(); 
    if(flag==0) 
        printf("\nEntered expression is 
Valid\n\n"); 
} 
void yyerror() 
{ 
    printf("\nEntered expression is 
Invalid\n\n"); 
    flag=1; 
} 




###########################################################################################################################################################################


LEXICAL ANALYZER USING C


#include<stdio.h> 
#include<ctype.h> 
#include<string.h> 
 
int main() 
{ 
    FILE *input; 
    int j=0; 
    int i,flag; 
    char ch,str[20]; 
    input = fopen("input.c","r"); 
    char keyword[30][30] = 
{"int","main","if","else","do","while","include
 ","void","printf","scanf"}; 
    printf("Lexeme \t\tToken \n\n"); 
    while(!feof(input)) 
    { 
        i=0; 
        flag=0; 
        ch=fgetc(input); 
        if( ch=='+' || ch== '-' || ch=='*' || ch=='/' ) 
        { 
            printf("%c\t\t Operator\n",ch); 
        } 
        else if( ch==';' || ch=='{' || ch=='}' || 
ch=='(' || ch==')' || ch=='?' || ch=='@' ||ch=='!'|| 
ch=='%') 
        { 
            printf("%c\t\t Special symbol\n",ch); 
        } 
        else if(isdigit(ch)) 
        { 
            printf("%c\t\t Digit\n",ch); 
        } 
else if(isalpha(ch)) 
        { 
            str[i]=ch; 
            i++; 
            ch=fgetc(input); 
            while(isalnum(ch) && ch!=' ') 
            { 
                str[i]=ch; 
                i++; 
                ch=fgetc(input); 
            } 
            str[i]='\0'; 
            for(j=0;j<=30;j++) 
            { 
                if(strcmp(str,keyword[j])==0) 
                { 
                    flag=1; 
                    break; 
                } 
            } 
            if(flag==1) 
            { 
                printf("%s\t\t Keyword\n",str); 
            } 
            else 
            { 
                printf("%s\t\t Identifier\n",str); 
            } 
        } 
    } 
    fclose(input); 
    return 0; 
} 


